= F
:experimental:

`f` lets you open files whose names you typed in the commandline some time before.
If the filename wasn't quoted, then it will be recognized and stored by `f`, which
you can then use in the future. It's like the famous https://www.github.com/rupa/z[rupa/z]
plugin and uses the frecency concept, but for files. Similar to it, `f` also needs
some time to learn the files you access the most and build a database. Usage is
fairly similar, but with some added niceties.

Most of the `f` source code has been modified from https://github.com/jethrokuan[jethrokuan's]
https://github.com/jethrokuan/z[z] port from bash to pure fish. Many, many thanks to him and
the original author of `z`, https://github.com/rupa[rupa].

== Example Usage

The files are opened by default with `$VISUAL`. If not set, `$EDITOR` will be used. One of
these variables has to be set. Use `--with` to open the files with another command. All files
are stored and retrieved as absolute paths.

-------
$ f --help

Usage: f [-do] [-r|-t] [-w cmd] [regex1 regex2 ..]
       f [-do] [-r|-t] [-w cmd] -k
       f [-r|-t] -l [regex1 regex2 ..]
       f -c|-p|-h

        -k --pick      Launch fzf for selection and then open with $EDITOR
        -w --with cmd  Open the file with command cmd rather than $EDITOR
        -d --cd        cd to the file directory after selection
        -c --clean     Remove files that no longer exist from $F_DATA
        -o --echo      Print match and return
        -l --list      List matches and scores
        -p --purge     Delete all entries from $F_DATA
        -r --rank      Search by rank
        -t --recent    Search by recency
        -h --help      Print this help

-------

=== Notable flags

Let's look at some interesting examples:

[source,fish]
------
$ f con fish  # open the best matched file that has "con" and "fish" somewhere in it's name
$ f --recent  # open the most recently mentioned file
$ f --pick  # Launch fzf to select a file from all files and open it
$ f --with less --pick  # Pick a file using fzf and view it using less
$ f --with rm --pick  # Filenames are simply passed as arguments to the --with command
$ f --cd --with 'ls -l' --pick  # Pick a file using fzf, cd to it's parent directory and run ls -l on the file
------

=== Keybindings

The whole reason I wrote this plugin was for this one feature -- insert filenames
into the command line without hitting tab a thousand times or doing a token search
with part of the filename. You can do this using the kbd:[Alt+K] keybinding.
This opens fzf and the filename you choose will be inserted into the commandline.

If kbd:[Alt+K] is already bound to something, it will not be overridden. Instead
you can bind `__f_insert_from_picker` to any key you wish:

[source,fish]
-----
$ bind \eu __f_insert_from_picker  # bind Alt-u
$ bind -M insert \eu __f_insert_from_picker  # for vim insert mode
-----

== Installation

`f` has been tested only on fish version 3, specifically `3.1.2`. Other versions should work
as the code is based on the fish port of `z` which works on fish `>=2.7.0`, though it is possible
that there is some compatibility issue. Please open an issue if you have trouble installing.

Recommended installation is through https://github.com/jorgebucaran/fisher[fisher]:

 fisher add gokulsoumya/f

== Configuration

`set -U F_CMD "p"`::
Change command from `f` to `p`.

`set -U F_DATA "$HOME/.foo"`::
Set data file to `$HOME/.foo` instead of `$XDG_DATA_HOME/f/data`.

`set -U F_EXCLUDE ".*password.*" ".*\.txt"`::
List of regex patterns to use to exlude files from being added
to `f` database.

`set -U F_OWNER "username"`::
Ensure data file is owned by `username`. This prevents usage of `f`
with `sudo` to cause file to be inaccessible in non-sudo sessions.

== FAQ

[qanda]

Backgrounding with `&` is not working with `f --with cmd`::
 https://github.com/fish-shell/fish-shell/issues/238[Functions cannot be backgrounded in fish],
 so something like `f --with gedit --pick &` won't work as expected.

Filenames I haven't typed in are showing up in the list::
 `f` works by scanning the command line and looking for valid filenames
 after each time a command is executed. If by some chance a file in a
 directory has the same name as some random token in the commandline, a
 false positive may be recorded. +
 Consider that a file called _status_ is present in the directory you're
 currently in. Now if you execute the `status` command, `f` will record
 the absolute path of the file _status_ in it's database. If you see this
 often with a particular file, you can make use of the `F_EXCLUDE`
 configuration variable.
